/**
 * Database schema definitions using Drizzle ORM.
 *
 * Defines tables for:
 * - generations: Track all media generations (images, videos, audio)
 * - watchedFolders: Folder watch configurations
 * - analytics: Daily aggregated usage statistics
 */

import { index, integer, real, sqliteTable, text } from 'drizzle-orm/sqlite-core';

// ============================================================================
// Generations Table
// ============================================================================

/**
 * Tracks all generations (images, videos, audio) made through the MCP server.
 *
 * This table stores metadata about each generation for:
 * - History browsing and search
 * - Cost tracking and analytics
 * - Asset management and retrieval
 */
export const generations = sqliteTable(
  'generations',
  {
    /**
     * Primary key - UUID generated by the server.
     */
    id: text('id').primaryKey(),

    /**
     * Type of task (imageInference, videoInference, audioInference, etc.)
     */
    taskType: text('task_type').notNull(),

    /**
     * UUID assigned by the Runware API for tracking the task.
     */
    taskUUID: text('task_uuid').notNull(),

    /**
     * The prompt used for generation.
     */
    prompt: text('prompt'),

    /**
     * Negative prompt used to exclude elements.
     */
    negativePrompt: text('negative_prompt'),

    /**
     * Model identifier used for generation.
     */
    model: text('model'),

    /**
     * Provider name (alibaba, bfl, kling, etc.)
     */
    provider: text('provider'),

    /**
     * Width of the generated media in pixels.
     */
    width: integer('width'),

    /**
     * Height of the generated media in pixels.
     */
    height: integer('height'),

    /**
     * Duration in seconds (for video/audio).
     */
    duration: integer('duration'),

    /**
     * URL to the generated output.
     */
    outputUrl: text('output_url'),

    /**
     * UUID of the generated output from Runware.
     */
    outputUuid: text('output_uuid'),

    /**
     * Output format (JPG, PNG, MP4, etc.)
     */
    outputFormat: text('output_format'),

    /**
     * Cost of the generation in credits.
     */
    cost: real('cost'),

    /**
     * JSON blob for additional parameters not in dedicated columns.
     */
    metadata: text('metadata'),

    /**
     * Current status of the generation.
     */
    status: text('status').notNull().default('completed'),

    /**
     * Error message if the generation failed.
     */
    errorMessage: text('error_message'),

    /**
     * Timestamp when the record was created (Unix epoch).
     */
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  },
  (table) => [
    index('idx_generations_task_type').on(table.taskType),
    index('idx_generations_task_uuid').on(table.taskUUID),
    index('idx_generations_status').on(table.status),
    index('idx_generations_created_at').on(table.createdAt),
    index('idx_generations_model').on(table.model),
    index('idx_generations_provider').on(table.provider),
  ],
);

// ============================================================================
// Watched Folders Table
// ============================================================================

/**
 * Stores configuration for folder watching.
 *
 * Each watched folder can have:
 * - A specific operation to perform on new files
 * - Custom parameters for that operation
 * - An output folder for processed files
 */
export const watchedFolders = sqliteTable(
  'watched_folders',
  {
    /**
     * Primary key - UUID generated by the server.
     */
    id: text('id').primaryKey(),

    /**
     * Absolute path to the folder being watched.
     */
    path: text('path').notNull().unique(),

    /**
     * Operation to perform on new files.
     * (upscale, removeBackground, caption, vectorize, controlnetPreprocess)
     */
    operation: text('operation').notNull(),

    /**
     * JSON blob with operation-specific parameters.
     */
    operationParams: text('operation_params'),

    /**
     * Optional output folder for processed files.
     * If not set, files are processed in place or returned to caller.
     */
    outputFolder: text('output_folder'),

    /**
     * Whether this folder watch is active.
     */
    isActive: integer('is_active', { mode: 'boolean' }).default(true),

    /**
     * Timestamp of the last scan (Unix epoch).
     */
    lastScan: integer('last_scan', { mode: 'timestamp' }),

    /**
     * Timestamp when the record was created (Unix epoch).
     */
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  },
  (table) => [
    index('idx_watched_folders_path').on(table.path),
    index('idx_watched_folders_is_active').on(table.isActive),
  ],
);

// ============================================================================
// Analytics Table
// ============================================================================

/**
 * Daily aggregated analytics for usage tracking.
 *
 * Pre-aggregated data for fast dashboard queries:
 * - Per-day, per-task-type, per-provider counts
 * - Total and average costs
 */
export const analytics = sqliteTable(
  'analytics',
  {
    /**
     * Primary key - UUID generated by the server.
     */
    id: text('id').primaryKey(),

    /**
     * Date in YYYY-MM-DD format.
     */
    date: text('date').notNull(),

    /**
     * Type of task being tracked.
     */
    taskType: text('task_type').notNull(),

    /**
     * Provider name (optional, for provider-specific breakdowns).
     */
    provider: text('provider'),

    /**
     * Number of generations for this combination.
     */
    count: integer('count').notNull().default(0),

    /**
     * Total cost for this combination.
     */
    totalCost: real('total_cost').notNull().default(0),

    /**
     * Average cost per generation (computed field, stored for query performance).
     */
    avgCost: real('avg_cost'),

    /**
     * Timestamp when the record was created (Unix epoch).
     */
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  },
  (table) => [
    index('idx_analytics_date').on(table.date),
    index('idx_analytics_task_type').on(table.taskType),
    index('idx_analytics_provider').on(table.provider),
    index('idx_analytics_date_task_type').on(table.date, table.taskType),
  ],
);
